#pragma config(Sensor, in2,    ArmPot,         sensorPotentiometer)
#pragma config(Sensor, in3,    leftEncoder,    sensorNone)
#pragma config(Sensor, in4,    potentiometer,  sensorNone)
#pragma config(Sensor, in5,    sonar,          sensorNone)
#pragma config(Sensor, in9,    SWITCH1,        sensorTouch)
#pragma config(Sensor, in10,   ARM_SWITCH,     sensorTouch)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,            ,             tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


//Competition Control and Duration Settings
//#pragma competitionControl(Competition)
#pragma autonomousDuration(2000)
//#pragma userControlDuration(0)



const int TAPE_THRESHOLD = 1000;
const int P_GAIN = 10;
//const int D_GAIN = 25;
const int SPEED = 50;
const int STATE_ON_TAPE = 0;
const int STATE_LEFT = -1;
const int STATE_FAR_LEFT = -5;
const int STATE_RIGHT = 1;
const int STATE_FAR_RIGHT = 5;
const int LEFT_MOTOR = port2;
const int RIGHT_MOTOR = port3;
const int TAPE_SENSOR_LEFT = 1;
const int TAPE_SENSOR_RIGHT = 2;

void TapeFollow();
void ReturnArmPositon(int angle);
int GetDistance();
void MaintainDistance(int angle);
/////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................


	motor[port2] = 127; //Full power is 127
	motor[port3] = 127;
	while ( 1 )	{    //loops forever
		if (SensorValue[SWITCH1] == 1)
			break;
	}
	wait1Msec(1000);


	//motor[LEFT_MOTOR] = 127; //Full power is 127
	//motor[RIGHT_MOTOR] = 127;
	//wait1Msec(3000);	//Run for three seconds

	//	motor[LEFT_MOTOR] = 0; //Full power is 127
	//motor[RIGHT_MOTOR] = 0;
	//wait1Msec(3000);	//Run for three seconds

	TapeFollow();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//

void TapeFollow(){
	int state = STATE_LEFT;
	int stateCount = 0;
	int pGain;
	//float dGain;
	int lastState = STATE_LEFT;
	int correction;
	while(true){
		int sensorValueRight = SensorValue[TAPE_SENSOR_RIGHT];
		int sensorValueLeft = SensorValue[TAPE_SENSOR_LEFT];
		if( (sensorValueRight > TAPE_THRESHOLD )&&  (sensorValueLeft  > TAPE_THRESHOLD )){
			state = STATE_ON_TAPE;
			stateCount = 0;
			lastState = STATE_ON_TAPE;
			} else if ( (sensorValueLeft < TAPE_THRESHOLD) &&  (sensorValueRight  < TAPE_THRESHOLD ) ){
			if( lastState == STATE_LEFT ){
				state = STATE_FAR_LEFT;
				}else if ( lastState == STATE_RIGHT){
				state = STATE_FAR_RIGHT;
			}
			stateCount++;
		}
		else if (sensorValueLeft < TAPE_THRESHOLD){
			state = STATE_LEFT;
			stateCount++;
			lastState = STATE_LEFT;
			} else if (sensorValueRight < TAPE_THRESHOLD){
			state = STATE_RIGHT;
			stateCount++;
			lastState = STATE_RIGHT;
		}
		//GAINS
		pGain = P_GAIN*state;

		if(stateCount != 0){
			//dGain = D_GAIN*(state-lastState)/stateCount;
			}else{
			//dGain =0;
		}
		correction = pGain; //+ dGain;
		//Motor Control
		motor[LEFT_MOTOR] = (SPEED - correction);
		motor[RIGHT_MOTOR] = (SPEED + correction);
	}
}

void ReturnArmPositon(int angle){
	int correction =0;
	int potValue = SensorValue[ArmPot];
	correction = potValue - correction;

	if(correction > 127){
		correction = 127;
		} else if( correction < -127){
		correction = -127
	}

	motor[ArmMotor] = correction;
}

int GetDistance(){

	int potValue;
	potValue = SensorValue[ArmPot];
}

void MaintainDistance(int angle){

}
