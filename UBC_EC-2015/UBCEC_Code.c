#pragma config(Sensor, in1,    TAPE_SENSOR_LEFT, sensorLineFollower)
#pragma config(Sensor, in2,    TAPE_SENSOR_RIGHT, sensorLineFollower)
#pragma config(Sensor, dgtl1,  switch1,        sensorTouch)
#pragma config(Motor,  port2,           LEFT_MOTOR,    tmotorServoContinuousRotation, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           RIGHT_MOTOR,   tmotorServoContinuousRotation, openLoop, driveRight)
#pragma config(Motor,  port4,           armServo,      tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma autonomousDuration(50000)

const int TAPE_THRESHOLD = 1200;
const int P_GAIN = 10;
const int D_GAIN = 25;
const int SPEED = 50;
const int STATE_LEFT = -1;
const int STATE_FAR_LEFT = -5;
const int STATE_RIGHT = 1;
const int STATE_FAR_RIGHT = 5;
const int UP_ARM = -127;
const int DOWN_ARM = 0;

void TapeFollow();
void Robo();
void TurnRightTape();
void TurnLeftTape();
void GoStraight();
void TapeFollowUntilSensor();
void Turn180();
void GoBackwards();

task main()
{
	stopMotor();
	setServo(armServo, UP_ARM);
	while ( 1 )	{    //loops forever
		if (SensorValue [switch1] == 1) break;
	}
	wait1Msec(1000);
	Robo();

}

void Robo(){
	TapeFollow();
	TurnRightTape();
	TapeFollow();
	GoStraight();
	TapeFollow();
	TapeFollowUntilSensor();
	setServo(armServo, DOWN_ARM);
	TurnLeftTape();
	TapeFollow();
	TurnRightTape();
	TapeFollow();
	GoStraight();
	TapeFollow();
	TurnLeftTape();
	TapeFollow();
	setServo(armServo, UP_ARM);
	Turn180();




}

void TapeFollow(){
	int state;
	int stateCount;
	int pGain;
	int dGain;
	int lastState;
	int correction;

	while(true){

		int sensorValueRight = SensorValue[TAPE_SENSOR_RIGHT];
		int sensorValueLeft = SensorValue[TAPE_SENSOR_LEFT];

		if( (sensorValueRight > TAPE_THRESHOLD )&&  (sensorValueLeft  > TAPE_THRESHOLD )){
			return;
			} else if ( (sensorValueLeft < TAPE_THRESHOLD) &&  (sensorValueRight  < TAPE_THRESHOLD ) ){
			if( lastState == STATE_LEFT ){
				state = STATE_FAR_LEFT;
				}else if ( lastState == STATE_RIGHT){
				state = STATE_FAR_RIGHT;
			}
			stateCount++;
		}
		else if (sensorValueLeft < TAPE_THRESHOLD){
			state = STATE_LEFT;
			stateCount++;
			lastState = STATE_LEFT;
			} else if (sensorValueRight < TAPE_THRESHOLD){
			state = STATE_RIGHT;
			stateCount++;
			lastState = STATE_RIGHT;
		}
		//GAINS
		pGain = P_GAIN*state;

		if(stateCount != 0){
			dGain = (int)((float)D_GAIN*(float)(state-lastState)/(float)stateCount);
			}else{
			dGain =0;
		}
		correction = pGain + dGain;
		//Motor Control
		motor[LEFT_MOTOR] = (SPEED - correction);
		motor[RIGHT_MOTOR] = (SPEED + correction);
	}
}

void TurnRightTape(){
	motor[LEFT_MOTOR] = SPEED;
	motor[RIGHT_MOTOR] = SPEED;
	wait1Msec(500);
	motor[LEFT_MOTOR] = SPEED;
	motor[RIGHT_MOTOR] = -SPEED;
	wait1Msec(400);

	while(true){
		if(SensorValue[TAPE_SENSOR_RIGHT] > TAPE_THRESHOLD){
			return;
		}
	}
}

void TurnLeftTape(){
	motor[LEFT_MOTOR] = SPEED;
	motor[RIGHT_MOTOR] = SPEED;
	wait1Msec(500);
	motor[LEFT_MOTOR] = -SPEED;
	motor[RIGHT_MOTOR] = SPEED;
	wait1Msec(400);
	while(true){
		if(SensorValue[TAPE_SENSOR_LEFT] > TAPE_THRESHOLD){
			return;
		}
	}
}

void GoStraight(){
	motor[LEFT_MOTOR] = SPEED;
	motor[RIGHT_MOTOR] = SPEED;
	wait1Msec(500);
}


void TapeFollowUntilSensor(){
	int state;
	int stateCount;
	int pGain;
	int dGain;
	int lastState;
	int correction;

	while(true){

		int sensorValueRight = SensorValue[TAPE_SENSOR_RIGHT];
		int sensorValueLeft = SensorValue[TAPE_SENSOR_LEFT];

		if( (sensorValueRight > TAPE_THRESHOLD )&&  (sensorValueLeft  > TAPE_THRESHOLD )){
			//return;
			} else if ( (sensorValueLeft < TAPE_THRESHOLD) &&  (sensorValueRight  < TAPE_THRESHOLD ) ){
			if( lastState == STATE_LEFT ){
				state = STATE_FAR_LEFT;
				}else if ( lastState == STATE_RIGHT){
				state = STATE_FAR_RIGHT;
			}
			stateCount++;
		}
		else if (sensorValueLeft < TAPE_THRESHOLD){
			state = STATE_LEFT;
			stateCount++;
			lastState = STATE_LEFT;
			} else if (sensorValueRight < TAPE_THRESHOLD){
			state = STATE_RIGHT;
			stateCount++;
			lastState = STATE_RIGHT;
		}
		//GAINS
		pGain = P_GAIN*state;

		if(stateCount != 0){
			dGain = (int)((float)D_GAIN*(float)(state-lastState)/(float)stateCount);
			}else{
			dGain =0;
		}

		if (SensorValue [switch1] == 1){
			motor[LEFT_MOTOR] = 0;
			motor[RIGHT_MOTOR] = 0;
			return;
		}
		correction = pGain + dGain;
		//Motor Control
		motor[LEFT_MOTOR] = (SPEED - correction);
		motor[RIGHT_MOTOR] = (SPEED + correction);
	}
}


void Turn180(){
	motor[LEFT_MOTOR] = -SPEED;
	motor[RIGHT_MOTOR] = -SPEED;
	wait1Msec(500);
	motor[LEFT_MOTOR] = SPEED;
	motor[RIGHT_MOTOR] = -SPEED;
	wait1Msec(400);

	while(true){
		if(SensorValue[TAPE_SENSOR_RIGHT] > TAPE_THRESHOLD){
			return;
		}
	}
}

void GoBackwards(){
	motor[LEFT_MOTOR] = -SPEED;
	motor[RIGHT_MOTOR] = -SPEED;
	wait1Msec(1500);
	motor[LEFT_MOTOR] = -SPEED;
	motor[RIGHT_MOTOR] = SPEED;
	wait1Msec(400);

	while(true){
		if(SensorValue[TAPE_SENSOR_LEFT] > TAPE_THRESHOLD){
			return;
		}
	}

}
